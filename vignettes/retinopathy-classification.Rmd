---
title: 'jdify: Retinopathy classification'
author: "Thomas Nagler"
date: "March 12, 2017"
output: markdown
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This vignette reproduces the results for the application section of the paper

> Nagler, T. (2017). *Nonparametric density estimation with discrete variables.*
Unpublished manuscript.

The goal is to diagnose diabetic retinopathy (a disease resulting from diabetes 
mellitus) from images of the retina. The retinal images have been preprocessed 
and a total of 19 features have been extracted. Three features are binary 
categories, six are integer valued count variables, and the remaining 10 
features are continuous measurements. For more information about the 
pre-processing and features, we refer to 
[Antal and Hajdu (2014)](https://arxiv.org/abs/1410.8576).

### Required libraries

```{r, warning = FALSE, message = FALSE}
library(tidyverse)
library(jdify)
set.seed(1)
```


### Data download and preparation

First we download the data set from the UCI repository.
```{r, message = FALSE}
URL <- "http://archive.ics.uci.edu/ml/machine-learning-databases/00329/messidor_features.arff"
dat <- as_tibble(foreign::read.arff(URL))
```


To let `jdify()` know which variables to treat as discrete, we have to 
declare them as `ordered`. We simply treat all integer values variables as 
discrete.
```{r}
dat[-20] <- dat[-20] %>% 
    map_if(~ all(. == round(.)), ~ ordered(., seq.int(min(.), max(.))))
dat
```


### Model fitting and performance assessment

We do 10-fold cross validation on all three joint density classifiers.

```{r, cache = TRUE}
cv_models <- list(liracine = "np", cckde = "cctools", vine = "kdevine") %>% 
    map(~ cv_jdify(Class ~ ., data = dat, .x, cores = 3, folds = 10))
```

Next, we extract (out-of-sample) class probabilities and calculate the 
performance measures:
```{r}
thresh <- seq(0, 1, length.out = 1000)
results <- cv_models %>%
    map("cv_probs") %>%
    map(~ assess_clsfyr(.x[, "1"], dat$Class == 1, c("FPR", "TPR"), thresh)) %>%
    bind_rows(.id = "method") %>%
    spread(measure, value) %>%
    group_by(method) %>%
    mutate(AUC = get_auc(cbind(FPR = FPR, TPR = TPR))) %>%
    ungroup()
```

In case we want to use the results for later analysis, we can store them now.
```{r, eval = FALSE}
save(results, file = "retinopathy-results.RData")
```


### ROC plot

Finally, we can create the ROC plot.

```{r}
results %>% 
    mutate(method = paste0(method, " (AUC = ", round(AUC, 2), ")  "),
           method = reorder(method, -AUC)) %>%
    ggplot(aes(FPR, TPR, col = method, linetype = method, AUC)) +
    geom_line(size = 0.7) +
    theme(legend.position = "top", legend.key.width = unit(7.5, "mm")) +
    labs(linetype = "", col = "")
```

To safe the plot (optional):
```{r, eval = FALSE}
ggsave("ROC.pdf", device = cairo_pdf, width = 7, height = 4)
```
